{
  "name": "Book Finder",
  "schema_version": "latest",
  "metadata": {
    "parameters": {
      "code": "import {\n  Text,\n  Group,\n  Stack,\n  Autocomplete,\n  Tooltip,\n  NumberInput,\n  TextInput,\n  Slider,\n  Checkbox,\n  ActionIcon,\n  Textarea,\n  AutocompleteItem,\n  Select,\n} from \"@mantine/core\";\nimport { useState, useCallback, useRef } from \"react\";\nimport { uniqueId } from \"lodash\";\nimport { IconHelp, IconPlus, IconTrash } from \"@tabler/icons-react\";\nimport UnionPropertyControl, {\n  UnionProperty,\n} from \"./property_controls/UnionPropertyControl\";\nimport { JSONObject, JSONValue } from \"aiconfig\";\n\nexport type StateSetFromPrevFn = (prev: JSONValue) => void;\nexport type SetStateFn = (val: StateSetFromPrevFn | JSONValue) => void;\n\nexport type PropertyRendererProps = {\n  propertyName: string;\n  property: JSONObject;\n  isRequired?: boolean;\n  initialValue?: JSONValue;\n  setValue: SetStateFn;\n};\n\nexport function PropertyLabel(props: {\n  propertyName: string;\n  propertyDescription: string;\n}) {\n  const { propertyName, propertyDescription } = props;\n  return propertyDescription != null && propertyDescription.trim() !== \"\" ? (\n    <Group spacing=\"xs\">\n      <Text size=\"md\">{propertyName}</Text>\n\n      <Tooltip label={propertyDescription} multiline maw={400}>\n        <ActionIcon>\n          <IconHelp size={16} />\n        </ActionIcon>\n      </Tooltip>\n    </Group>\n  ) : (\n    <Text size=\"md\">{propertyName}</Text>\n  );\n}\n\nexport default function SettingsPropertyRenderer({\n  propertyName,\n  property,\n  isRequired = false,\n  initialValue = null,\n  setValue,\n}: PropertyRendererProps) {\n  const propertyType = property.type;\n  const defaultValue = property.default;\n  const propertyDescription = property.description;\n  const [propertyValue, setPropertyValue] = useState(\n    initialValue ?? defaultValue\n  );\n\n  let propertyControl;\n  \n  const setAndPropagateValue = useCallback(\n    (newValue: ((prev: JSONValue) => void) | JSONValue) => {\n      const valueToSet =\n        typeof newValue === \"function\" ? newValue(propertyValue) : newValue;\n\n        \n      if (propertyName != null && propertyName.trim() !== \"\") {\n        setValue((prevValue: JSONValue) => ({\n          ...(prevValue && typeof prevValue === \"object\" ? prevValue : {}),\n          [propertyName]: valueToSet,\n        }));\n      } else {\n        setValue(valueToSet);\n      }\n\n      setPropertyValue(valueToSet);\n    },\n    [propertyName, propertyValue, setValue]\n  );\n\n  // Used in the case the property is an array\n  // TODO: Should initialize with values from settings if available\n  const [itemControls, setItemControls] = useState<JSX.Element[]>([]);\n  const itemValues = useRef(propertyValue ?? new Map<string, JSONValue>());\n\n  if (propertyName ===\"functions\"){\n    console.log(\"|||||\")\n    console.log(itemControls)\n    console.log(initialValue),\n    console.log(propertyValue ?? new Map<string, JSONValue>())\n    console.log(\"|||||||\")\n  }\n\n  const removeItemFromList = useCallback(\n    async (key: string) => {\n      setItemControls((prevItemControls) =>\n        prevItemControls.filter((item) => item.key !== key)\n      );\n\n      itemValues.current.delete(key);\n      setAndPropagateValue(Array.from(itemValues.current.values()));\n    },\n    [setAndPropagateValue]\n  );\n\n  const addItemToList = useCallback(async () => {\n    const key = uniqueId();\n    setItemControls((prevItemControls) => [\n      ...prevItemControls,\n      <Group key={key}>\n        <SettingsPropertyRenderer\n          propertyName=\"\"\n          property={property.items}\n          setValue={(newItem) => {\n            itemValues.current.set(key, newItem);\n            setAndPropagateValue(Array.from(itemValues.current.values()));\n          }}\n        />\n        <ActionIcon onClick={() => removeItemFromList(key)}>\n          <IconTrash size={16} />\n        </ActionIcon>\n      </Group>,\n    ]);\n  }, [property.items, removeItemFromList, setAndPropagateValue]);\n\n  switch (propertyType) {\n    case \"string\": {\n      if (property.enum != null) {\n        propertyControl = (\n          <Autocomplete\n            label={\n              <PropertyLabel\n                propertyName={propertyName}\n                propertyDescription={propertyDescription}\n              />\n            }\n            filter={(value: string, item: AutocompleteItem) => {\n              const label: string = item.value.toLocaleLowerCase();\n              const val = value.toLocaleLowerCase().trim();\n\n              // If selected value matches enum exactly (selected case), show all options\n              if (\n                property.enum &&\n                property.enum.some((v: string) => v === val)\n              ) {\n                return true;\n              }\n\n              // Include item if typed value is a substring\n              return label.includes(val);\n            }}\n            required={isRequired}\n            placeholder={propertyValue ?? \"select\"}\n            data={property.enum}\n            value={propertyValue ?? \"\"}\n            onChange={setAndPropagateValue}\n          />\n        );\n      } else {\n        propertyControl = (\n          <TextInput\n            label={\n              <PropertyLabel\n                propertyName={propertyName}\n                propertyDescription={propertyDescription}\n              />\n            }\n            placeholder={propertyValue}\n            required={isRequired}\n            withAsterisk={isRequired}\n            radius=\"md\"\n            value={propertyValue ?? \"\"}\n            onChange={(event) =>\n              setAndPropagateValue(event.currentTarget.value)\n            }\n          />\n        );\n      }\n      break;\n    }\n    case \"text\": {\n      propertyControl = (\n        <Textarea\n          label={\n            <PropertyLabel\n              propertyName={propertyName}\n              propertyDescription={propertyDescription}\n            />\n          }\n          placeholder={propertyValue}\n          required={isRequired}\n          withAsterisk={isRequired}\n          radius=\"md\"\n          value={propertyValue ?? \"\"}\n          onChange={(event) => setAndPropagateValue(event.currentTarget.value)}\n          autosize\n        />\n      );\n      break;\n    }\n    case \"number\": {\n      if (property.minimum != null && property.maximum != null) {\n        propertyControl = (\n          <Stack>\n            <PropertyLabel\n              propertyName={propertyName}\n              propertyDescription={propertyDescription}\n            />\n            <Slider\n              defaultValue={propertyValue ?? property.minimum}\n              min={property.minimum}\n              max={property.maximum}\n              label={(value) => value.toFixed(1)}\n              step={property.step ?? 0.1}\n              styles={{ markLabel: { display: \"none\" } }}\n              value={propertyValue}\n              onChange={setAndPropagateValue}\n              style={{ padding: \"0 0.5em\" }}\n            />\n          </Stack>\n        );\n      } else {\n        propertyControl = (\n          <NumberInput\n            label={\n              <PropertyLabel\n                propertyName={propertyName}\n                propertyDescription={propertyDescription}\n              />\n            }\n            defaultValue={propertyValue}\n            min={property.minimum}\n            max={property.maximum}\n            step={property.step ?? 0.05}\n            precision={property.precision ?? 2}\n            required={isRequired}\n            withAsterisk={isRequired}\n            radius=\"md\"\n            value={propertyValue ?? \"\"}\n            onChange={(val) => setAndPropagateValue(val)}\n          />\n        );\n      }\n      break;\n    }\n    case \"integer\": {\n      if (property.minimum != null && property.maximum != null) {\n        propertyControl = (\n          <Stack>\n            <PropertyLabel\n              propertyName={propertyName}\n              propertyDescription={propertyDescription}\n            />\n            <Slider\n              defaultValue={propertyValue ?? property.minimum}\n              min={property.minimum}\n              max={property.maximum}\n              label={(value) => value.toFixed(0)}\n              step={property.step ?? 1}\n              styles={{ markLabel: { display: \"none\" } }}\n              value={propertyValue}\n              onChange={setAndPropagateValue}\n              style={{ padding: \"0 0.5em\" }}\n            />\n          </Stack>\n        );\n      } else {\n        propertyControl = (\n          <NumberInput\n            label={\n              <PropertyLabel\n                propertyName={propertyName}\n                propertyDescription={propertyDescription}\n              />\n            }\n            defaultValue={propertyValue}\n            min={property.minimum}\n            max={property.maximum}\n            step={property.step ?? 1}\n            required={isRequired}\n            withAsterisk={isRequired}\n            radius=\"md\"\n            value={propertyValue ?? \"\"}\n            onChange={(val) => setAndPropagateValue(val)}\n          />\n        );\n      }\n      break;\n    }\n    case \"boolean\": {\n      propertyControl = (\n        <Checkbox\n          label={\n            <PropertyLabel\n              propertyName={propertyName}\n              propertyDescription={propertyDescription}\n            />\n          }\n          checked={propertyValue}\n          onChange={(event) =>\n            setAndPropagateValue(event.currentTarget.checked)\n          }\n        />\n      );\n      break;\n    }\n    case \"array\": {\n      propertyControl = (\n        <>\n          <Group align=\"end\">\n            <Text size=\"md\">{propertyName}</Text>\n            {propertyDescription != null &&\n            propertyDescription.trim() !== \"\" ? (\n              <Tooltip label={propertyDescription} multiline>\n                <ActionIcon>\n                  <IconHelp size={16} />\n                </ActionIcon>\n              </Tooltip>\n            ) : null}\n            <ActionIcon onClick={() => addItemToList()}>\n              <IconPlus size={16} />\n            </ActionIcon>\n          </Group>\n          <Stack>{itemControls}</Stack>\n        </>\n      );\n      break;\n    }\n    case \"object\": {\n      const requiredFields = new Set<string>(property.required ?? []);\n\n      const subproperties = property.properties;\n\n      const subpropertyControls = [];\n\n      for (const subpropertyName in subproperties) {\n        const isRequired = requiredFields.has(subpropertyName);\n        const subproperty = subproperties[subpropertyName];\n\n        if (subproperty.exclude === true) {\n          continue;\n        }\n\n        subpropertyControls.push(\n          <SettingsPropertyRenderer\n            isRequired={isRequired}\n            property={subproperty}\n            propertyName={subpropertyName}\n            key={subpropertyName}\n            initialValue={\n              (initialValue as JSONObject | undefined)?.[subpropertyName]\n            }\n            setValue={setAndPropagateValue}\n          />\n        );\n      }\n\n      if (subpropertyControls.length > 0) {\n        propertyControl = (\n          <>\n            {propertyName != null && propertyName.trim() !== \"\" ? (\n              <Text>{propertyName}</Text>\n            ) : (\n              <></>\n            )}\n            <Stack>{subpropertyControls}</Stack>\n          </>\n        );\n      }\n\n      break;\n    }\n    case \"select\": {\n      if (property.values != null) {\n        propertyControl = (\n          <Select\n            label={\n              <PropertyLabel\n                propertyName={propertyName}\n                propertyDescription={propertyDescription}\n              />\n            }\n            data={property.values}\n            value={propertyValue}\n            onChange={(val) => {\n              setAndPropagateValue(val);\n            }}\n            defaultValue={property.default}\n          ></Select>\n        );\n      }\n      break;\n    }\n    case \"union\": {\n      propertyControl = (\n        <Stack>\n          <PropertyLabel\n            propertyName={propertyName}\n            propertyDescription={propertyDescription}\n          />\n          <UnionPropertyControl\n            property={property as UnionProperty}\n            isRequired={isRequired}\n            propertyName={propertyName}\n            initialValue={initialValue}\n            setValue={setAndPropagateValue}\n            renderProperty={(props) => <SettingsPropertyRenderer {...props} />}\n          />\n        </Stack>\n      );\n      break;\n    }\n    default: {\n      console.warn(\n        `Warning: Unable to render property '${propertyName}' of type '${propertyType}'.`\n      );\n    }\n  }\n\n  // TODO: Support toggling to monaco JSON editor at top level\n  return propertyControl ?? null;\n}\n\n",
      "": ""
    },
    "models": {}
  },
  "description": "Use OpenAI function calling to help recommend books",
  "prompts": [
    {
      "name": "recommend_book",
      "input": "I really enjoyed reading {{book}}, could you recommend me a book that is similar and tell me why? tsd!",
      "metadata": {
        "model": {
          "name": "gpt-3.5-turbo",
          "settings": {
            "functions": [
              {
                "description": "list queries books by genre, and returns a list of names of books",
                "name": "list",
                "parameters": {
                  "properties": {
                    "genre": {
                      "enum": [
                        "mystery",
                        "nonfiction",
                        "memoir",
                        "romance",
                        "historicald"
                      ],
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              },
              {
                "description": "search queries books by their name and returns a list of book names and their ids",
                "name": "search",
                "parameters": {
                  "properties": {
                    "name": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              },
              {
                "description": "get returns a book's detailed information based on the id of the book. Note that this does not accept names, and only IDs, which you can get by using search.",
                "name": "get",
                "parameters": {
                  "properties": {
                    "id": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                }
              }
            ],
            "model": "gpt-3.5-turbo",
            "system_prompt": {
              "content": "Please use our book database, which you can access using functions to answer the following questions.",
              "role": "system"
            }
          }
        },
        "parameters": {
          "book": "To Kill a Mockingbird"
        },
        "remember_chat_context": true
      }
    },
    {
      "name": "gen_summary",
      "input": "in this code how do I initialize the itemControls with propertyValue if if propertyType is an array?\n\n{{code}}",
      "metadata": {
        "model": {
          "name": "gpt-4",
          "settings": {}
        },
        "parameters": {
          "code": "import {\n  Text,\n  Group,\n  Stack,\n  Autocomplete,\n  Tooltip,\n  NumberInput,\n  TextInput,\n  Slider,\n  Checkbox,\n  ActionIcon,\n  Textarea,\n  AutocompleteItem,\n  Select,\n} from \"@mantine/core\";\nimport { useState, useCallback, useRef } from \"react\";\nimport { uniqueId } from \"lodash\";\nimport { IconHelp, IconPlus, IconTrash } from \"@tabler/icons-react\";\nimport UnionPropertyControl, {\n  UnionProperty,\n} from \"./property_controls/UnionPropertyControl\";\nimport { JSONObject, JSONValue } from \"aiconfig\";\n\nexport type StateSetFromPrevFn = (prev: JSONValue) => void;\nexport type SetStateFn = (val: StateSetFromPrevFn | JSONValue) => void;\n\nexport type PropertyRendererProps = {\n  propertyName: string;\n  property: JSONObject;\n  isRequired?: boolean;\n  initialValue?: JSONValue;\n  setValue: SetStateFn;\n};\n\nexport function PropertyLabel(props: {\n  propertyName: string;\n  propertyDescription: string;\n}) {\n  const { propertyName, propertyDescription } = props;\n  return propertyDescription != null && propertyDescription.trim() !== \"\" ? (\n    <Group spacing=\"xs\">\n      <Text size=\"md\">{propertyName}</Text>\n\n      <Tooltip label={propertyDescription} multiline maw={400}>\n        <ActionIcon>\n          <IconHelp size={16} />\n        </ActionIcon>\n      </Tooltip>\n    </Group>\n  ) : (\n    <Text size=\"md\">{propertyName}</Text>\n  );\n}\n\nexport default function SettingsPropertyRenderer({\n  propertyName,\n  property,\n  isRequired = false,\n  initialValue = null,\n  setValue,\n}: PropertyRendererProps) {\n  const propertyType = property.type;\n  const defaultValue = property.default;\n  const propertyDescription = property.description;\n  const [propertyValue, setPropertyValue] = useState(\n    initialValue ?? defaultValue\n  );\n\n  let propertyControl;\n  \n  const setAndPropagateValue = useCallback(\n    (newValue: ((prev: JSONValue) => void) | JSONValue) => {\n      const valueToSet =\n        typeof newValue === \"function\" ? newValue(propertyValue) : newValue;\n\n        \n      if (propertyName != null && propertyName.trim() !== \"\") {\n        setValue((prevValue: JSONValue) => ({\n          ...(prevValue && typeof prevValue === \"object\" ? prevValue : {}),\n          [propertyName]: valueToSet,\n        }));\n      } else {\n        setValue(valueToSet);\n      }\n\n      setPropertyValue(valueToSet);\n    },\n    [propertyName, propertyValue, setValue]\n  );\n\n  // Used in the case the property is an array\n  // TODO: Should initialize with values from settings if available\n  const [itemControls, setItemControls] = useState<JSX.Element[]>([]);\n  const itemValues = useRef(propertyValue ?? new Map<string, JSONValue>());\n\n  if (propertyName ===\"functions\"){\n    console.log(\"|||||\")\n    console.log(itemControls)\n    console.log(initialValue),\n    console.log(propertyValue ?? new Map<string, JSONValue>())\n    console.log(\"|||||||\")\n  }\n\n  const removeItemFromList = useCallback(\n    async (key: string) => {\n      setItemControls((prevItemControls) =>\n        prevItemControls.filter((item) => item.key !== key)\n      );\n\n      itemValues.current.delete(key);\n      setAndPropagateValue(Array.from(itemValues.current.values()));\n    },\n    [setAndPropagateValue]\n  );\n\n  const addItemToList = useCallback(async () => {\n    const key = uniqueId();\n    setItemControls((prevItemControls) => [\n      ...prevItemControls,\n      <Group key={key}>\n        <SettingsPropertyRenderer\n          propertyName=\"\"\n          property={property.items}\n          setValue={(newItem) => {\n            itemValues.current.set(key, newItem);\n            setAndPropagateValue(Array.from(itemValues.current.values()));\n          }}\n        />\n        <ActionIcon onClick={() => removeItemFromList(key)}>\n          <IconTrash size={16} />\n        </ActionIcon>\n      </Group>,\n    ]);\n  }, [property.items, removeItemFromList, setAndPropagateValue]);\n\n  switch (propertyType) {\n    case \"string\": {\n      if (property.enum != null) {\n        propertyControl = (\n          <Autocomplete\n            label={\n              <PropertyLabel\n                propertyName={propertyName}\n                propertyDescription={propertyDescription}\n              />\n            }\n            filter={(value: string, item: AutocompleteItem) => {\n              const label: string = item.value.toLocaleLowerCase();\n              const val = value.toLocaleLowerCase().trim();\n\n              // If selected value matches enum exactly (selected case), show all options\n              if (\n                property.enum &&\n                property.enum.some((v: string) => v === val)\n              ) {\n                return true;\n              }\n\n              // Include item if typed value is a substring\n              return label.includes(val);\n            }}\n            required={isRequired}\n            placeholder={propertyValue ?? \"select\"}\n            data={property.enum}\n            value={propertyValue ?? \"\"}\n            onChange={setAndPropagateValue}\n          />\n        );\n      } else {\n        propertyControl = (\n          <TextInput\n            label={\n              <PropertyLabel\n                propertyName={propertyName}\n                propertyDescription={propertyDescription}\n              />\n            }\n            placeholder={propertyValue}\n            required={isRequired}\n            withAsterisk={isRequired}\n            radius=\"md\"\n            value={propertyValue ?? \"\"}\n            onChange={(event) =>\n              setAndPropagateValue(event.currentTarget.value)\n            }\n          />\n        );\n      }\n      break;\n    }\n    case \"text\": {\n      propertyControl = (\n        <Textarea\n          label={\n            <PropertyLabel\n              propertyName={propertyName}\n              propertyDescription={propertyDescription}\n            />\n          }\n          placeholder={propertyValue}\n          required={isRequired}\n          withAsterisk={isRequired}\n          radius=\"md\"\n          value={propertyValue ?? \"\"}\n          onChange={(event) => setAndPropagateValue(event.currentTarget.value)}\n          autosize\n        />\n      );\n      break;\n    }\n    case \"number\": {\n      if (property.minimum != null && property.maximum != null) {\n        propertyControl = (\n          <Stack>\n            <PropertyLabel\n              propertyName={propertyName}\n              propertyDescription={propertyDescription}\n            />\n            <Slider\n              defaultValue={propertyValue ?? property.minimum}\n              min={property.minimum}\n              max={property.maximum}\n              label={(value) => value.toFixed(1)}\n              step={property.step ?? 0.1}\n              styles={{ markLabel: { display: \"none\" } }}\n              value={propertyValue}\n              onChange={setAndPropagateValue}\n              style={{ padding: \"0 0.5em\" }}\n            />\n          </Stack>\n        );\n      } else {\n        propertyControl = (\n          <NumberInput\n            label={\n              <PropertyLabel\n                propertyName={propertyName}\n                propertyDescription={propertyDescription}\n              />\n            }\n            defaultValue={propertyValue}\n            min={property.minimum}\n            max={property.maximum}\n            step={property.step ?? 0.05}\n            precision={property.precision ?? 2}\n            required={isRequired}\n            withAsterisk={isRequired}\n            radius=\"md\"\n            value={propertyValue ?? \"\"}\n            onChange={(val) => setAndPropagateValue(val)}\n          />\n        );\n      }\n      break;\n    }\n    case \"integer\": {\n      if (property.minimum != null && property.maximum != null) {\n        propertyControl = (\n          <Stack>\n            <PropertyLabel\n              propertyName={propertyName}\n              propertyDescription={propertyDescription}\n            />\n            <Slider\n              defaultValue={propertyValue ?? property.minimum}\n              min={property.minimum}\n              max={property.maximum}\n              label={(value) => value.toFixed(0)}\n              step={property.step ?? 1}\n              styles={{ markLabel: { display: \"none\" } }}\n              value={propertyValue}\n              onChange={setAndPropagateValue}\n              style={{ padding: \"0 0.5em\" }}\n            />\n          </Stack>\n        );\n      } else {\n        propertyControl = (\n          <NumberInput\n            label={\n              <PropertyLabel\n                propertyName={propertyName}\n                propertyDescription={propertyDescription}\n              />\n            }\n            defaultValue={propertyValue}\n            min={property.minimum}\n            max={property.maximum}\n            step={property.step ?? 1}\n            required={isRequired}\n            withAsterisk={isRequired}\n            radius=\"md\"\n            value={propertyValue ?? \"\"}\n            onChange={(val) => setAndPropagateValue(val)}\n          />\n        );\n      }\n      break;\n    }\n    case \"boolean\": {\n      propertyControl = (\n        <Checkbox\n          label={\n            <PropertyLabel\n              propertyName={propertyName}\n              propertyDescription={propertyDescription}\n            />\n          }\n          checked={propertyValue}\n          onChange={(event) =>\n            setAndPropagateValue(event.currentTarget.checked)\n          }\n        />\n      );\n      break;\n    }\n    case \"array\": {\n      propertyControl = (\n        <>\n          <Group align=\"end\">\n            <Text size=\"md\">{propertyName}</Text>\n            {propertyDescription != null &&\n            propertyDescription.trim() !== \"\" ? (\n              <Tooltip label={propertyDescription} multiline>\n                <ActionIcon>\n                  <IconHelp size={16} />\n                </ActionIcon>\n              </Tooltip>\n            ) : null}\n            <ActionIcon onClick={() => addItemToList()}>\n              <IconPlus size={16} />\n            </ActionIcon>\n          </Group>\n          <Stack>{itemControls}</Stack>\n        </>\n      );\n      break;\n    }\n    case \"object\": {\n      const requiredFields = new Set<string>(property.required ?? []);\n\n      const subproperties = property.properties;\n\n      const subpropertyControls = [];\n\n      for (const subpropertyName in subproperties) {\n        const isRequired = requiredFields.has(subpropertyName);\n        const subproperty = subproperties[subpropertyName];\n\n        if (subproperty.exclude === true) {\n          continue;\n        }\n\n        subpropertyControls.push(\n          <SettingsPropertyRenderer\n            isRequired={isRequired}\n            property={subproperty}\n            propertyName={subpropertyName}\n            key={subpropertyName}\n            initialValue={\n              (initialValue as JSONObject | undefined)?.[subpropertyName]\n            }\n            setValue={setAndPropagateValue}\n          />\n        );\n      }\n\n      if (subpropertyControls.length > 0) {\n        propertyControl = (\n          <>\n            {propertyName != null && propertyName.trim() !== \"\" ? (\n              <Text>{propertyName}</Text>\n            ) : (\n              <></>\n            )}\n            <Stack>{subpropertyControls}</Stack>\n          </>\n        );\n      }\n\n      break;\n    }\n    case \"select\": {\n      if (property.values != null) {\n        propertyControl = (\n          <Select\n            label={\n              <PropertyLabel\n                propertyName={propertyName}\n                propertyDescription={propertyDescription}\n              />\n            }\n            data={property.values}\n            value={propertyValue}\n            onChange={(val) => {\n              setAndPropagateValue(val);\n            }}\n            defaultValue={property.default}\n          ></Select>\n        );\n      }\n      break;\n    }\n    case \"union\": {\n      propertyControl = (\n        <Stack>\n          <PropertyLabel\n            propertyName={propertyName}\n            propertyDescription={propertyDescription}\n          />\n          <UnionPropertyControl\n            property={property as UnionProperty}\n            isRequired={isRequired}\n            propertyName={propertyName}\n            initialValue={initialValue}\n            setValue={setAndPropagateValue}\n            renderProperty={(props) => <SettingsPropertyRenderer {...props} />}\n          />\n        </Stack>\n      );\n      break;\n    }\n    default: {\n      console.warn(\n        `Warning: Unable to render property '${propertyName}' of type '${propertyType}'.`\n      );\n    }\n  }\n\n  // TODO: Support toggling to monaco JSON editor at top level\n  return propertyControl ?? null;\n}\n\n"
        },
        "remember_chat_context": true
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "execution_count": 0,
          "data": "If `propertyType` is an array, then apart from existing functionality, you should initialize the `itemControls` as per the values present in `propertyValue` if `propertyValue` is not null.\n\nThe same can be achieved by following these steps:\n\n1. Use `useEffect` from react to listen for changes in `propertyValue`.\n2. If `propertyValue` is an array, iterate over it and add `SettingsPropertyRenderer` for each item in `propertyValue` like we are doing in `addItemToList`.\n\nHere is the code you should add just after `itemValues` declaration:\n\n```javascript\n  // Run this piece of code only once in beginning and when propertyValue changes\n  useEffect(() => {\n    // If propertyValue is an array then,\n    if (Array.isArray(propertyValue)){\n      // Initialize itemControls with propertyValue\n      const initialItemControls = propertyValue.map((val, idx) => \n        <Group key={idx}>\n          <SettingsPropertyRenderer\n            propertyName=\"\"\n            property={property.items}\n            setValue={(newItem) => {\n              itemValues.current.set(idx, newItem);\n              setAndPropagateValue(Array.from(itemValues.current.values()));\n            }}\n          />\n          <ActionIcon onClick={() => removeItemFromList(idx)}>\n            <IconTrash size={16} />\n          </ActionIcon>\n        </Group>\n      );\n      \n      // Update state\n      setItemControls(initialItemControls);\n    }\n    // We are using setValue and property.items as dependencies but you can remove these if not required.\n  }, [propertyValue, setValue, property.items]);\n```",
          "metadata": {
            "id": "chatcmpl-8gEuQUl0DqEJYFmESXrxCLMZ9j1Io",
            "created": 1705077778,
            "model": "gpt-4-0613",
            "object": "chat.completion.chunk",
            "raw_response": {
              "content": "If `propertyType` is an array, then apart from existing functionality, you should initialize the `itemControls` as per the values present in `propertyValue` if `propertyValue` is not null.\n\nThe same can be achieved by following these steps:\n\n1. Use `useEffect` from react to listen for changes in `propertyValue`.\n2. If `propertyValue` is an array, iterate over it and add `SettingsPropertyRenderer` for each item in `propertyValue` like we are doing in `addItemToList`.\n\nHere is the code you should add just after `itemValues` declaration:\n\n```javascript\n  // Run this piece of code only once in beginning and when propertyValue changes\n  useEffect(() => {\n    // If propertyValue is an array then,\n    if (Array.isArray(propertyValue)){\n      // Initialize itemControls with propertyValue\n      const initialItemControls = propertyValue.map((val, idx) => \n        <Group key={idx}>\n          <SettingsPropertyRenderer\n            propertyName=\"\"\n            property={property.items}\n            setValue={(newItem) => {\n              itemValues.current.set(idx, newItem);\n              setAndPropagateValue(Array.from(itemValues.current.values()));\n            }}\n          />\n          <ActionIcon onClick={() => removeItemFromList(idx)}>\n            <IconTrash size={16} />\n          </ActionIcon>\n        </Group>\n      );\n      \n      // Update state\n      setItemControls(initialItemControls);\n    }\n    // We are using setValue and property.items as dependencies but you can remove these if not required.\n  }, [propertyValue, setValue, property.items]);\n```",
              "role": "assistant"
            },
            "role": "assistant"
          }
        }
      ]
    }
  ],
  "$schema": "https://json.schemastore.org/aiconfig-1.0"
}